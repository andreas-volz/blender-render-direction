import bpy
import os
import math
from bpy.props import (StringProperty,
                       BoolProperty,
                       IntProperty,
                       FloatProperty,
                       EnumProperty,
                       PointerProperty,
                       CollectionProperty
                       )
from bpy.types import (Panel,
                       Operator,
                       PropertyGroup,
                       UIList
                       )
                       
class TestPropGroup(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="name", default="Text")
    value: bpy.props.IntProperty(name="value", default=5)
    res_x: bpy.props.IntProperty(name="Resolution X", default=256)
    res_y: bpy.props.IntProperty(name="Resolution Y", default=256)
    frames: bpy.props.IntProperty(name="Frames (1/x)", default=4)
    direction_E: bpy.props.BoolProperty(name="E", default=True)
    direction_NE: bpy.props.BoolProperty(name="NE", default=True)
    direction_N: bpy.props.BoolProperty(name="N", default=True)
    direction_NW: bpy.props.BoolProperty(name="NW", default=True)
    direction_W: bpy.props.BoolProperty(name="W", default=True)
    direction_SW: bpy.props.BoolProperty(name="SW", default=True)
    direction_S: bpy.props.BoolProperty(name="S", default=True)
    direction_SE: bpy.props.BoolProperty(name="SE", default=True)
    
bpy.utils.register_class(TestPropGroup)

class ListItem(PropertyGroup): 
    """Group of properties representing an item in the list.""" 
    name: StringProperty( 
        name="Name", 
        description="A name for this item", 
        default="Untitled") 

    random_prop: StringProperty( 
        name="Any other property you want", 
        description="", default="")

bpy.utils.register_class(ListItem)

class MY_UL_List(UIList):
    """Demo UIList."""

    def draw_item(self, context, layout, data, item, icon, active_data,
                  active_propname, index):

        # We could write some code to decide which icon to use here...
        custom_icon = 'OBJECT_DATAMODE'

        # Make sure your code supports all 3 layout types
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            layout.label(text=item.name, icon = custom_icon)

        elif self.layout_type in {'GRID'}:
            layout.alignment = 'CENTER'
            layout.label(text="", icon = custom_icon)


bpy.utils.register_class(MY_UL_List)

class LIST_OT_NewItem(Operator):
    """Add a new item to the list."""

    bl_idname = "my_list.new_item"
    bl_label = "Add a new item"

    def execute(self, context):
        #context.scene.my_list.clear()
        context.scene.my_list.add()

        return{'FINISHED'}

bpy.utils.register_class(LIST_OT_NewItem)

class LIST_OT_DeleteItem(Operator):
    """Delete the selected item from the list."""

    bl_idname = "my_list.delete_item"
    bl_label = "Deletes an item"

    @classmethod
    def poll(cls, context):
        return context.scene.my_list

    def execute(self, context):
        my_list = context.scene.my_list
        index = context.scene.list_index

        my_list.remove(index)
        context.scene.list_index = min(max(0, index - 1), len(my_list) - 1)

        return{'FINISHED'}
    
bpy.utils.register_class(LIST_OT_DeleteItem)

class LIST_OT_ClearList(Operator):
    """Clear all items of the list"""
    bl_idname = "my_list.clear_list"
    bl_label = "Clear List"
    bl_description = "Clear all items of the list"
    bl_options = {'INTERNAL'}

    @classmethod
    def poll(cls, context):
        return bool(context.scene.my_list)

    def invoke(self, context, event):
        return context.window_manager.invoke_confirm(self, event)

    def execute(self, context):
        if bool(context.scene.my_list):
            context.scene.my_list.clear()
            self.report({'INFO'}, "All items removed")
        else:
            self.report({'INFO'}, "Nothing to remove")
        return {'FINISHED'}

bpy.utils.register_class(LIST_OT_ClearList)


class TEST_PT_panel_p(bpy.types.Panel):
    bl_idname = 'TEST_PT_panel_p'
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "render"
    bl_label = 'Direction Renderer'
 

    
         
    def draw(self, context):
        scene = context.scene
        object = context.object
        
        
        self.layout.label(text="Settings to export rendered images:")
        

        row = self.layout.row()
        row.prop(context.scene.test_prop, "res_x")
        row.prop(context.scene.test_prop, "res_y")
        row = self.layout.row()
        row.prop(context.scene.test_prop, "frames")
        
        self.layout.label(text="Directions:")
        row = self.layout.row()
        row.prop(context.scene.test_prop, "direction_E")
        row.prop(context.scene.test_prop, "direction_NE")
        row.prop(context.scene.test_prop, "direction_N")
        row.prop(context.scene.test_prop, "direction_NW")
        row = self.layout.row()
        row.prop(context.scene.test_prop, "direction_W")
        row.prop(context.scene.test_prop, "direction_SW")
        row.prop(context.scene.test_prop, "direction_S")
        row.prop(context.scene.test_prop, "direction_SE")
        


        
        row = self.layout.row()
        row.template_list("MY_UL_List", "The_List", scene,
                          "my_list", scene, "list_index")


        row = self.layout.row()
        row.operator('my_list.new_item', text='NEW')
        row.operator('my_list.delete_item', text='REMOVE')
        row.operator('my_list.clear_list', text='CLEAR')
         
#        if scene.list_index >= 0 and scene.my_list:
#            item = scene.my_list[scene.list_index]

#            row = self.layout.row()
#            row.prop(item, "name")
#            row.prop(item, "random_prop")
            

        
        # sample operator call
        self.layout.operator(
            operator='object.render_operator',
            icon='BLENDER',
            text='Create direction images'
        )        

        
    def register():
        bpy.types.Scene.test_prop = bpy.props.PointerProperty(type=TestPropGroup)
        bpy.types.Scene.my_list = CollectionProperty(type = ListItem)
        
        bpy.types.Scene.list_index = IntProperty(name = "Index for my_list", default = 0)

        #bpy.types.Scene.float_x = bpy.props.FloatProperty(default=4.5)
        #bpy.types.Scene.cube_x = bpy.props.IntProperty()
        

            
    def unregister():
        del bpy.types.Scene.test_prop


class RenderOperator(bpy.types.Operator):
    bl_idname = "object.render_operator"
    bl_label = "Tool Name"

    def execute(self, context):
        print("Hello Render")
        
        index = context.scene.list_index
        name = context.scene.my_list[index].name
        print(name)
        
        #return {'FINISHED'}

        path = '/home/andreas/tmp/mutant'
        # path fixing
        path = os.path.abspath(path)

        # get list of selected objects
        selected_list = bpy.context.selected_objects

        # deselect all in scene
        bpy.ops.object.select_all(action='TOGGLE')

        s = bpy.context.scene

        s.render.resolution_x = context.scene.test_prop.res_x
        s.render.resolution_y = context.scene.test_prop.res_y

        
        # I left this in as in some of my models, I needed to translate the "root" object but
        # the animations were on the armature which I selected.
        # 
        # obRoot = bpy.context.scene.objects["root"]


        # loop all initial selected objects (which will likely just be one object.. I haven't tried setting up multiple yet)
        for o in selected_list:
            
            # select the object
            bpy.context.scene.objects[o.name].select_set(True)

            scn = bpy.context.scene
            
            # loop through the actions
            for a in bpy.data.actions:
                #assign the action
                bpy.context.active_object.animation_data.action = bpy.data.actions.get(a.name)
                
                #dynamically set the last frame to render based on action
                scn.frame_end = int(bpy.context.active_object.animation_data.action.frame_range[1])
                
                #set which actions you want to render.  Make sure to use the exact name of the action!
                if (
                    a.name == name
#                     a.name == "idle"
#                     a.name == "run"
#                     or a.name == "dying"
                    ):
                    
                    #create folder for animation
                    action_folder = os.path.join(path, a.name)
                    if not os.path.exists(action_folder):
                        os.makedirs(action_folder)
                    
                    #loop through all 8 directions
                    for angle in range(0, 360, 45):
                        if angle == 0:
                            angleDir = "E"
                        if angle == 45:
                            angleDir = "NE"
                        if angle == 90:
                            angleDir = "N"
                        if angle == 135:
                            angleDir = "NW"
                        if angle == 180:
                            angleDir = "W"
                        if angle == 225:
                            angleDir = "SW"
                        if angle == 270:
                            angleDir = "S"
                        if angle == 315:
                            angleDir = "SE"
                            
                        #set which angles we want to render.
                        if (   (angle == 0 and context.scene.test_prop.direction_E == True)
                            or (angle == 45 and context.scene.test_prop.direction_NE == True)
                            or (angle == 90 and context.scene.test_prop.direction_N == True)
                            or (angle == 135 and context.scene.test_prop.direction_NW == True)
                            or (angle == 180 and context.scene.test_prop.direction_W == True)
                            or (angle == 225 and context.scene.test_prop.direction_SW == True)
                            or (angle == 270 and context.scene.test_prop.direction_S == True)
                            or (angle == 315 and context.scene.test_prop.direction_SE == True)
                            ):
                            
                            #create folder for specific angle
                            animation_folder = os.path.join(action_folder, angleDir)
                            if not os.path.exists(animation_folder):
                                os.makedirs(animation_folder)
                            
                            #rotate the model for the new angle
                            bpy.context.active_object.rotation_euler[2] = math.radians(angle)
                            
                            # the below is for the use case where the root needed to be translated.
    #                        obRoot.rotation_euler[2] = math.radians(angle)
                            
                            
                            #loop through and render frames.  Can set how "often" it renders.
                            #Every frame is likely not needed.  Currently set to 2 (every other).
                            
                            # TBD: some frame numbering logic needed!
                            
                            for i in range(s.frame_start,s.frame_end, context.scene.test_prop.frames):
                                s.frame_current = i

                                s.render.filepath = (
                                                    animation_folder
                                                    + "\\"
                                                    + str(a.name)
                                                    + "_"
                                                    + str(angle)
                                                    + "_"
                                                    + str(s.frame_current).zfill(3)
                                                    )
                                                    
                                bpy.ops.render.render( #{'dict': "override"},
                                                      #'INVOKE_DEFAULT',  
                                                      False,            # undo support
                                                      animation=False, 
                                                      write_still=True
                                                     )
                                                     
        return {'FINISHED'}

bpy.utils.register_class(TEST_PT_panel_p)
bpy.utils.register_class(RenderOperator)

bpy.context.scene.my_list.clear()

# populate the action animations list with items
for a in bpy.data.actions:
    item = bpy.context.scene.my_list.add()
    item.name = a.name
        
#render8directions_selected_objects('/home/andreas/tmp/mutant')
