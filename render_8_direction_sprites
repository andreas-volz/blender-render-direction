import bpy
import os
import math
from bpy.props import (StringProperty,
                       BoolProperty,
                       IntProperty,
                       FloatProperty,
                       EnumProperty,
                       PointerProperty,
                       CollectionProperty
                       )
from bpy.types import (Panel,
                       Operator,
                       PropertyGroup,
                       UIList
                       )
from bpy_extras.io_utils import ImportHelper
from bpy.types import Operator
                       
class RenderPropGroup(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="name", default="Text")
    dirname: bpy.props.StringProperty(name="Output", default="/tmp/")
    value: bpy.props.IntProperty(name="value", default=5)
    res_x: bpy.props.IntProperty(name="Resolution X", default=256)
    res_y: bpy.props.IntProperty(name="Resolution Y", default=256)
    frames: bpy.props.IntProperty(name="Frames (1/x)", default=4)
    direction_E: bpy.props.BoolProperty(name="E", default=True)
    direction_NE: bpy.props.BoolProperty(name="NE", default=True)
    direction_N: bpy.props.BoolProperty(name="N", default=True)
    direction_NW: bpy.props.BoolProperty(name="NW", default=True)
    direction_W: bpy.props.BoolProperty(name="W", default=True)
    direction_SW: bpy.props.BoolProperty(name="SW", default=True)
    direction_S: bpy.props.BoolProperty(name="S", default=True)
    direction_SE: bpy.props.BoolProperty(name="SE", default=True)
    
bpy.utils.register_class(RenderPropGroup)

class OT_OpenFilebrowser(Operator, ImportHelper):

    bl_idname = "filebrowser.render_path"
    bl_label = "Select render folder"
     
    filter_glob: StringProperty(
        default='*',
        options={'HIDDEN'}
    )
    
    some_boolean: BoolProperty(
        name='Do a thing',
        description='Do a thing with the file you\'ve selected'
    )

    def execute(self, context):
        """Do something with the selected file(s)."""

        filebase, extension = os.path.splitext(self.filepath)
        
        dirname, basename = os.path.split(self.filepath)
        
        print('Selected file:', self.filepath)
        print('filebase:', filebase)
        print('dirname:', dirname)
        print('basename:', basename)
        print('File extension:', extension)
        print('Some Boolean:', self.some_boolean)
        
        context.scene.render_prop.dirname = dirname
        
        return {'FINISHED'}

class ListItem(PropertyGroup): 
    """Group of properties representing an item in the list.""" 
    name: StringProperty( 
        name="Name", 
        description="A name for this item", 
        default="Untitled") 

    active: BoolProperty( 
        name="Active", 
        description="A name for this item", 
        default=False)
        
    random_prop: StringProperty( 
        name="Any other property you want", 
        description="", default="")

bpy.utils.register_class(ListItem)

class MY_UL_List(UIList):
    """Demo UIList."""

    def draw_item(self, context, layout, data, item, icon, active_data,
                  active_propname, index):

        # We could write some code to decide which icon to use here...
        if item.active == True:
            custom_icon = 'CHECKBOX_HLT'
        else:
            custom_icon = 'CHECKBOX_DEHLT'

        # Make sure your code supports all 3 layout types
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            layout.label(text=item.name, icon = custom_icon)

        elif self.layout_type in {'GRID'}:
            layout.alignment = 'CENTER'
            layout.label(text="", icon = custom_icon)

        layout.enabled = item.active

bpy.utils.register_class(MY_UL_List)

class LIST_OT_NewItem(Operator):
    """Add a new item to the list."""

    bl_idname = "my_list.new_item"
    bl_label = "Add a new item"

    def execute(self, context):
        list = context.scene.my_list.add()

        return{'FINISHED'}

bpy.utils.register_class(LIST_OT_NewItem)

class LIST_OT_DeleteItem(Operator):
    """Delete the selected item from the list."""

    bl_idname = "my_list.delete_item"
    bl_label = "Deletes an item"

    @classmethod
    def poll(cls, context):
        return context.scene.my_list

    def execute(self, context):
        my_list = context.scene.my_list
        index = context.scene.list_index

        my_list.remove(index)
        context.scene.list_index = min(max(0, index - 1), len(my_list) - 1)

        return{'FINISHED'}

bpy.utils.register_class(LIST_OT_DeleteItem)

class LIST_OT_ActivateItem(Operator):
    """Activate the selected item from the list."""

    bl_idname = "my_list.activate_item"
    bl_label = "Activate an item"

    @classmethod
    def poll(cls, context):
        return context.scene.my_list

    def execute(self, context):
        my_list = context.scene.my_list
        index = context.scene.list_index
        
        context.scene.my_list[index].active = True

        return{'FINISHED'}
    
bpy.utils.register_class(LIST_OT_ActivateItem)
 
class LIST_OT_DeactivateItem(Operator):
    """Deactivate the selected item from the list."""

    bl_idname = "my_list.deactivate_item"
    bl_label = "Deactivate an item"

    @classmethod
    def poll(cls, context):
        return context.scene.my_list

    def execute(self, context):
        my_list = context.scene.my_list
        index = context.scene.list_index
        
        context.scene.my_list[index].active = False

        return{'FINISHED'}
    
bpy.utils.register_class(LIST_OT_DeactivateItem)

class LIST_OT_ClearList(Operator):
    """Clear all items of the list"""
    bl_idname = "my_list.clear_list"
    bl_label = "Clear List"
    bl_description = "Clear all items of the list"
    bl_options = {'INTERNAL'}

    @classmethod
    def poll(cls, context):
        return bool(context.scene.my_list)

    def invoke(self, context, event):
        return context.window_manager.invoke_confirm(self, event)

    def execute(self, context):
        if bool(context.scene.my_list):
            context.scene.my_list.clear()
            self.report({'INFO'}, "All items removed")
        else:
            self.report({'INFO'}, "Nothing to remove")
        return {'FINISHED'}

bpy.utils.register_class(LIST_OT_ClearList)


class RENDER_PT_panel_p(bpy.types.Panel):
    bl_idname = 'RENDER_PT_panel_p'
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "output"
    bl_label = 'Direction Renderer'
 
    def draw(self, context):
        scene = context.scene
        object = context.object
        
        self.layout.label(text="Settings to export rendered images:")
 
        row = self.layout.row()
        row.prop(context.scene.render_prop, "res_x")
        row.prop(context.scene.render_prop, "res_y")
        row = self.layout.row()
        row.prop(context.scene.render_prop, "frames")
        
        self.layout.label(text="Directions:")
        row = self.layout.row()
        row.prop(context.scene.render_prop, "direction_E")
        row.prop(context.scene.render_prop, "direction_NE")
        row.prop(context.scene.render_prop, "direction_N")
        row.prop(context.scene.render_prop, "direction_NW")
        row = self.layout.row()
        row.prop(context.scene.render_prop, "direction_W")
        row.prop(context.scene.render_prop, "direction_SW")
        row.prop(context.scene.render_prop, "direction_S")
        row.prop(context.scene.render_prop, "direction_SE")
        
        #row.prop_search(bpy.context.scene, "*",  bpy.data, "armatures")
        
        split = self.layout.split(factor=0.92)
        
        col = split.column()
        col.template_list("MY_UL_List", "The_List", scene,
                          "my_list", scene, "list_index")

        col = split.column()
        col.operator('my_list.activate_item', text='', icon='CHECKBOX_HLT')
        col.operator('my_list.deactivate_item', text='', icon='CHECKBOX_DEHLT')

        row = self.layout.row()

        split = self.layout.split(factor=0.92)

        col = split.column()
        col.prop(context.scene.render_prop, "dirname")
        
        col = split.column()
        col.operator(
            operator='filebrowser.render_path',
            icon='FILEBROWSER',
            text=''
        )
         
        # render operator call
        self.layout.operator(
            operator='object.render_operator',
            icon='RENDER_RESULT',
            text='Create direction images'
        )

        
    def register():
        bpy.types.Scene.render_prop = bpy.props.PointerProperty(type=RenderPropGroup)
        bpy.types.Scene.my_list = CollectionProperty(type = ListItem)
        
        bpy.types.Scene.list_index = IntProperty(name = "Index for my_list", default = 0)

        #bpy.types.Scene.float_x = bpy.props.FloatProperty(default=4.5)
        #bpy.types.Scene.cube_x = bpy.props.IntProperty()
        
    def unregister():
        del bpy.types.Scene.render_prop


class RenderOperator(bpy.types.Operator):
    bl_idname = "object.render_operator"
    bl_label = "Render Operator"

    def execute(self, context):
        print("Hello Render")
        
        #index = context.scene.list_index
        #name = context.scene.my_list[index].name
        #print(name)
        
        #for item in context.scene.my_list:
        #    print("name:" + item.name)
        
        # only to debug the render operation
        #return {'FINISHED'}

        path = context.scene.render_prop.dirname
        # path fixing
        path = os.path.abspath(path)
        
        print("renderpath: " + path)

        # get list of selected objects
        selected_list = bpy.context.selected_objects

        # deselect all in scene
        bpy.ops.object.select_all(action='TOGGLE')

        s = bpy.context.scene

        s.render.resolution_x = context.scene.render_prop.res_x
        s.render.resolution_y = context.scene.render_prop.res_y

        
        # I left this in as in some of my models, I needed to translate the "root" object but
        # the animations were on the armature which I selected.
        # 
        # obRoot = bpy.context.scene.objects["root"]

        only_armatures = True
        for o in selected_list:
            if o.type != 'ARMATURE':
                only_armatures = False
        
        if only_armatures == False:
            self.report({'WARNING'}, "Please select only Armatures. (Current: %s)" % o.type)
            return {'FINISHED'}
        
        # loop all initial selected objects (which will likely just be one object.. I haven't tried setting up multiple yet)        
        for o in selected_list:
                        
            # select the object
            bpy.context.scene.objects[o.name].select_set(True)

            scn = bpy.context.scene

            # loop through the actions
            for item in context.scene.my_list:
                # render only in the UIList activated actions
                if item.active == False:
                    continue
                
                #assign the action
                bpy.context.active_object.animation_data.action = bpy.data.actions.get(item.name)
                
                #dynamically set the last frame to render based on action
                scn.frame_end = int(bpy.context.active_object.animation_data.action.frame_range[1])
                
                #set which actions you want to render.  Make sure to use the exact name of the action!
                #if (a.name == name):
                
                #create folder for animation
                action_folder = os.path.join(path, item.name)
                if not os.path.exists(action_folder):
                    os.makedirs(action_folder)
                
                #loop through all 8 directions
                for angle in range(0, 360, 45):
                    if angle == 0:
                        angleDir = "E"
                    if angle == 45:
                        angleDir = "NE"
                    if angle == 90:
                        angleDir = "N"
                    if angle == 135:
                        angleDir = "NW"
                    if angle == 180:
                        angleDir = "W"
                    if angle == 225:
                        angleDir = "SW"
                    if angle == 270:
                        angleDir = "S"
                    if angle == 315:
                        angleDir = "SE"
                        
                    #set which angles we want to render.
                    if (   (angle == 0 and context.scene.render_prop.direction_E == True)
                        or (angle == 45 and context.scene.render_prop.direction_NE == True)
                        or (angle == 90 and context.scene.render_prop.direction_N == True)
                        or (angle == 135 and context.scene.render_prop.direction_NW == True)
                        or (angle == 180 and context.scene.render_prop.direction_W == True)
                        or (angle == 225 and context.scene.render_prop.direction_SW == True)
                        or (angle == 270 and context.scene.render_prop.direction_S == True)
                        or (angle == 315 and context.scene.render_prop.direction_SE == True)
                        ):
                        
                        #create folder for specific angle
                        animation_folder = os.path.join(action_folder, angleDir)
                        if not os.path.exists(animation_folder):
                            os.makedirs(animation_folder)
                        
                        #rotate the model for the new angle
                        bpy.context.active_object.rotation_euler[2] = math.radians(angle)
                        
                        # the below is for the use case where the root needed to be translated.
                        # obRoot.rotation_euler[2] = math.radians(angle)
                        
                        # loop through and render frames.  The UI sets how "often" it renders.
                        # Every frame is likely not needed.                          
                        for i in range(s.frame_start,s.frame_end, context.scene.render_prop.frames):
                            s.frame_current = i

                            s.render.filepath = (
                                                animation_folder
                                                + "\\"
                                                + str(item.name)
                                                + "_"
                                                + str(angle)
                                                + "_"
                                                + str(s.frame_current).zfill(3)
                                                )
                                                
                            bpy.ops.render.render( #{'dict': "override"},
                                                  #'INVOKE_DEFAULT',  
                                                  False,            # undo support
                                                  animation=False, 
                                                  write_still=True
                                                 )
                                                     
        return {'FINISHED'}

bpy.utils.register_class(RENDER_PT_panel_p)
bpy.utils.register_class(RenderOperator)

bpy.context.scene.my_list.clear()

# populate the action animations list with items
for a in bpy.data.actions:
    item = bpy.context.scene.my_list.add()
    item.name = a.name
    
        
def register():
    bpy.utils.register_class(OT_OpenFilebrowser)


def unregister():
    bpy.utils.unregister_class(OT_OpenFilebrowser)


if __name__ == "__main__":
    register()

